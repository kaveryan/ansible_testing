#!/usr/bin/env python
# -*- encoding: utf-8 -*-
import socket
import sys
import uuid
import json
import traceback
import struct
import select
import requests
import os
import copy
import threading, Queue, thread
import fcntl
import time
import yaml
import getopt
import signal
import hashlib
import chardet

reload(sys)
sys.setdefaultencoding("utf-8")

#自定义异常类
class FileExists(Exception):
    def __init__(self):
        Exception.__init__(self)

#退出的类
class Watcher():
    def __init__(self):
        self.child = os.fork()
        if self.child == 0:
            return
        else:
            self.watch()

    def watch(self):
        try:
            os.wait()
        except KeyboardInterrupt:
            print "退出！"
            self.kill()
        sys.exit()

    def kill(self):
        try:
            os.kill(self.child, signal.SIGKILL)
        except OSError:
            pass

#写日志
class DevopsLog(object):
    def __init__(self,level=1,logpath=''):
        #level:1 debug,2 warn,3 error
        # print 'start'
        try:
            if not os.path.exists(logpath):
                os.makedirs(logpath)
            if level in [1,2,3]:
                self.level = level
                self.formatLen = 30#样式长度
                self.maxLogSize = 20*1024*1024
                # self.maxLogSize = 200*1024*1024
                # print self.level
                self.logpath = logpath
                self.initcode = 0

            else:
                print '日志级别非法'
                self.initcode = 1
        #Exception
        except Exception:
            print '日志参数有误：',traceback.format_exc()
            self.initcode = 1

    def Log(self,currentLevel,message):
        #处理日志内容
        try:
            if not message:
                return 0
            message = self.DealLog(message)
            if self.initcode == 0:
                if  currentLevel == 1 and self.level < 2:
                    return self.WriteLog("debug",message)
                elif currentLevel == 2 and self.level < 3:
                    return self.WriteLog("warn", message)
                elif currentLevel == 3 and self.level < 4:
                    return self.WriteLog("error", message)
                else:
                    return 0
        except Exception:
            print '写日志出现异常:', traceback.format_exc()
            return 0

    def WriteLog(self,currentLevel,message):
        # 判定文件是否存在，不存在则创建新的文件
        logFilePath = os.path.join(self.logpath, 'deploy.log')
        createTimeout = 300
        i = 1
        while i < createTimeout:#不断重写文件直到成功
            try:
                if not os.path.isfile(logFilePath):
                    with open(logFilePath, 'w') as f:
                        f.close()
                break
            except Exception:
                pass
            time.sleep(1)
            i += 1

        if i == createTimeout:
            print '创建文件超时（%d）！' % createTimeout
            return 0

        # 判断文件是否可写，可写则加文件锁，写入内容后释放,不可写则等待5s后再判断，超时则抛出写日志异常，然后退出
        writeTimeout = 300
        i = 1
        while i < writeTimeout:
            if os.access(logFilePath, os.W_OK):
                with open(logFilePath, 'a+') as f:
                    # print 'lock'
                    fcntl.flock(f, fcntl.LOCK_EX)
                    log_time = time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(time.time()))
                    if currentLevel == 'warn':
                        f.write(log_time + ' [' + currentLevel + ']  : ' + message + '\n')
                    else:
                        f.write(log_time + ' [' + currentLevel + '] : ' + message + '\n')
                    fcntl.flock(f, fcntl.LOCK_UN)
                    # print 'unlock'
                    #写完后如果文件大于指定大小则重命名
                    if os.path.getsize(logFilePath) > self.maxLogSize:
                        temp_time = time.strftime('%Y%m%d%H%M%S', time.localtime(time.time()))
                        os.rename(logFilePath,logFilePath + '.'+ temp_time)
                    break
            time.sleep(1)
            i += 1
        if i == createTimeout:
            print '写日志超时（%d）！' % writeTimeout
            return 0



    def DealLog(self,message):
        if isinstance(message,basestring):
            # print 'string:',message.replace('\n','\n'+' '* self.formatLen)
            return message.replace('\n','\n'+' '* self.formatLen)
        if isinstance(message,dict):
            message = self.PrettyDict(message)
            return message
        if isinstance(message,list):
            message = self.PrettyList(message)
            return message


    def PrettyDict(self,obj, ):
        return yaml.dump(obj).replace('\n','\n'+' '* self.formatLen)

    def PrettyList(self,dataList):
        newdataList = []
        for i in dataList: newdataList.append(str(i))
        split_str = '\n'+' '* self.formatLen
        return split_str.join(newdataList)

#创建线程
class MyThread(threading.Thread):

    def __init__(self, func, arg=None):
        super(MyThread, self).__init__()  #调用父类的构造函数
        self.func = func  #传入线程函数逻辑
        self.arg = arg

    def run(self):
        if self.arg:
            self.func(self.arg)
        else:
            self.func()

class AutoRegister(object):
    def __init__(self,data):
        self.bind = bind
        self.weburl = weburl
        self.token = token
        self.workqueue = Queue.Queue()
        self.resultqueue = Queue.Queue()
        self.time = None
        self.log = None

    def Register(self):
        # print "PushMissionResult"
        while True:
            data = self.resultqueue.get()
            ###push result
            headers = {
                'Accept': 'application/json',
                'Authorization': 'Token ' + self.token,
                'User-Agent': 'Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:22.0) Gecko/20100101 Firefox/22.0',
                'content-type': 'application/json'
            }
            data['methon'] = 'pushmissionresult'
            result = requests.post(self.weburl, headers=headers, json=json.dumps(data))

class DevopsWorker(object):
    def __init__(self,bind=None,weburl=None,token=None,worktype=None,serverurl=None,proxyurl=None,arg=None, loglevel=None, logpath=None):
        self.bind = bind
        self.weburl = weburl
        self.token = token
        self.workqueue = Queue.Queue()
        self.resultqueue = Queue.Queue()
        self.time = None
        self.log = None
        self.workinglist = []
        self.worktype = worktype
        self.serverurl = serverurl
        self.proxyurl = proxyurl
        self.arg = arg
        self.structpack = '1024s1024s128sII'

        #初始化日志对象
        self.logger = DevopsLog(loglevel, logpath)

    def WorkerNameToWork(self,name):
        print "WorkerNameToWork","----",name
        self.logger.Log(1, "WorkerNameToWork----" + name)
        try:
            if name == 'GetMission':
                #建立获取任务的线程
                threadname = 'GetMission_' + self.GetTime()
                thread = MyThread(self.GetMission)
                thread.setName(threadname)
                thread.start()  #线程开始处理任务

            if name.find('StartBindTo') >=0 :
                #建立监听线程
                bindinfo = name.split("To")[1]
                threadname = 'StartBindTo' + bindinfo + "_" + self.GetTime()
                thread = MyThread(self.StartBind,bindinfo)
                thread.setName(threadname)
                thread.start()  #线程开始处理任务

            if name == 'PushMissionResult':
                #建立监听线程
                threadname = 'PushMissionResult_' + self.GetTime()
                thread = MyThread(self.PushMissionResult)
                thread.setName(threadname)
                thread.start()  #线程开始处理任务

            if name == 'ServerWorker':
                #建立监听线程
                threadname = 'ServerWorker_' + self.GetTime()
                thread = MyThread(self.ServerWorker)
                thread.setName(threadname)
                thread.start()  #线程开始处理任务

            if name == 'ProxyResultToServer':
                #建立监听线程
                threadname = 'ProxyResultToServer_' + self.GetTime()
                thread = MyThread(self.ProxyResultToServer)
                thread.setName(threadname)
                thread.start()  #线程开始处理任务

            if name == 'ProxyWorker':
                #建立监听线程
                threadname = 'ProxyWorker_' + self.GetTime()
                thread = MyThread(self.ProxyWorker)
                thread.setName(threadname)
                thread.start()  #线程开始处理任务

        except Exception as e:
            a = traceback.format_exc()
            self.logger.Log(1, a)
            # traceback.format_exc()

    def Guard(self):
        self.workinglist = []
        if self.worktype == 'server':
            self.workinglist = [
                    'GetMission',
                    'PushMissionResult',
                    'ServerWorker',
                ]
            for bind in self.bind:
                self.workinglist.append('StartBindTo' + bind)
        elif self.worktype == 'proxy':
            self.workinglist = [
                    'ProxyResultToServer',
                    'ProxyWorker',
                ]
            for bind in self.bind:
                self.workinglist.append('StartBindTo' + bind)
        if not self.workinglist:
            print "请定义工作模式"
            self.logger.Log(3, "请定义工作模式")
            return

        while True:
            threadnamelist = [thread.getName().split("_")[0] for thread in threading.enumerate()]
            print "存活线程:" + ",".join(threadnamelist)
            self.logger.Log(1, "存活线程:" + ",".join(threadnamelist))
            for workername in self.workinglist:
                if not workername in threadnamelist:
                    self.WorkerNameToWork(workername)
            time.sleep(60)

    def GetTime(self):
        self.time = time.strftime('%Y-%m-%d_%H:%M:%S',time.localtime(time.time()))
        return self.time

    def DivList(self,ls,n):
        ####功能：将list对象N等分
        if not isinstance(ls,list) or not isinstance(n,int):
            return []
        ls_len = len(ls)
        if n<=0 or 0==ls_len:
            return []
        if n > ls_len:
            return []
        elif n == ls_len:
            return [[i] for i in ls]
        else:
            j = ls_len/n
            k = ls_len%n
            ### j,j,j,...(前面有n-1个j),j+k
            #步长j,次数n-1
            ls_return = []
            for i in xrange(0,(n-1)*j,j):
                ls_return.append(ls[i:i+j])
            #算上末尾的j+k
            ls_return.append(ls[(n-1)*j:])
            return ls_return

    def FunctionDefined(self,f):
        try:
            return (" " + f).zfill(40)
        except Exception as e:
            a = traceback.format_exc()
            self.logger.Log(1, a)
            # traceback.format_exc()
            return " ".zfill(40)

    #数据拆分与接收
    def SendData(self,c, data):
        # Prefix each message with a 4-byte length (network byte order)
        data = struct.pack('>I', len(data)) + data
        try:
            c.sendall(data)
        except socket.error, e:
            pass

    def RecvAll(self,c, n):
        # Helper function to recv n bytes or return None if EOF is hit
        data = b''
        try:
            while len(data) < n:
                packet = c.recv(n - len(data))
                if not packet:
                    return None
                data += packet
        except socket.error, e:
            return None
        return data

    def RecvData(self,c):
        # Read message length and unpack it into an integer
        raw_msglen = self.RecvAll(c, 4)
        if not raw_msglen:
            return None
        msglen = struct.unpack('>I', raw_msglen)[0]
        # Read the message data
        return self.RecvAll(c, msglen)

    def GetFileMD5(self, filepath):
        code = ''
        try:
            '''
            check md5
            :param missionfile:
            :return: file md5
            '''
            if not os.path.isfile(filepath):
                return
            myhash = hashlib.md5()
            f = file(filepath, 'rb')
            while True:
                b = f.read(8096)
                if not b:
                    break
                myhash.update(b)
            f.close()
            # print '最新文件的md5:',myhash.hexdigest()
            code = myhash.hexdigest()
        except Exception as e:
            a = traceback.format_exc()
            print a
        finally:
            return code

    def GetMission(self):
        # print "GetMission"
        while True:
            headers = {
                'Accept': 'application/json',
                'Authorization': 'Token ' + self.token,
                'User-Agent': 'Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:22.0) Gecko/20100101 Firefox/22.0',
                'content-type': 'application/json'
            }
            data = {'methon':'getmission'}
            try:
                r = requests.post(self.weburl, headers=headers,json=json.dumps(data))
                if not r.json()['code']:
                    missionlist = json.loads(r.json()['data'])
                    # self.logger.Log(1, missionlist)
                    for mission in missionlist:
                        self.workqueue.put(mission)
            except requests.ConnectionError:
                print '网站获取待执行任务的api不可用'
                self.logger.Log(3, '网站获取待执行任务的api不可用')
            except Exception as e:
                a = traceback.format_exc()
                self.logger.Log(1, a)
                # traceback.format_exc()
            finally:
                interval = 60
                if self.arg.has_key('GetMissionInterval'):
                    interval = self.arg['GetMissionInterval']
                time.sleep(interval)

    def PushMissionResult(self):
        # print "PushMissionResult"
        while True:
            data = self.resultqueue.get()
            ###push result
            headers = {
                'Accept': 'application/json',
                'Authorization': 'Token ' + self.token,
                'User-Agent': 'Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:22.0) Gecko/20100101 Firefox/22.0',
                'content-type': 'application/json'
            }
            data['methon'] = 'pushmissionresult'
            result = requests.post(self.weburl, headers=headers, json=json.dumps(data))

    def ProxyResultToServer(self):
        # print "PushMissionResult"
        while True:
            data = self.resultqueue.get()
            if data:
                try:
                    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                    s.connect((self.serverurl.split(":")[0],int(self.serverurl.split(":")[1])))
                    s.send(self.FunctionDefined('missionresult'))
                    self.SendData(s, json.dumps(data))
                    s.close()
                except Exception as e:
                    a = traceback.format_exc()
                    self.logger.Log(1, a)
                    # traceback.format_exc()
                    SocketReconnectInterval = 10
                    if self.arg.has_key('SocketReconnectInterval'):
                        SocketReconnectInterval = self.arg['SocketReconnectInterval']
                    print "回传任务结果出错服务端" + self.serverurl + "将在" + str(SocketReconnectInterval) + "秒后重新尝试连接"
                    self.logger.Log(3, "回传任务结果出错服务端" + self.serverurl + "将在" + str(SocketReconnectInterval) + "秒后重新尝试连接")
                    time.sleep(SocketReconnectInterval)
                    self.resultqueue.put(data)

    def ProxyWorkModuleAnsible(self,data,missionid):
        try:
            import ansibleV20API as ansible
            #脚本执行环境
            script_evr = {
                'sh': 'bash ',
                'py': 'python ',
                'ps1': '.\\',
                'vbs': 'cscript ',
                'bat': None,
            }
            #重组inventory
            data['inventory'] = {}
            data['inventory']['groups'] = []
            data['hostnametoip'] = {}
            existgroup = []
            for i in data.pop('target'):
                if not i['groupname'] in existgroup:
                    existgroup.append(i['groupname'])
                    data['inventory']['groups'].append({'groupname':i['groupname'],'hosts':[]})
                if i['hosts'].has_key('ip'):
                    if i['hosts']['ip']:
                        ip = i['hosts'].pop('ip').pop()
                        data['hostnametoip'][i['hosts']['hostname']] = ip
                        i['hosts']['hostname'] = ip
                credential = i['hosts'].pop('credential')
                if credential:
                    if i['groupname'].lower() == 'windows':
                        i['hosts']['variable'] = {
                            "ansible_user": credential['username'],
                            "ansible_password": credential['password'],
                            "ansible_port": "5986",
                            "ansible_connection": "winrm",
                            "ansible_winrm_server_cert_validation":"ignore",
                        }
                    elif i['groupname'].lower() == 'linux':
                        i['hosts']['variable'] = {
                            "ansible_user": credential['username'],
                            "ansible_password": credential['password'],
                            "ansible_port": "22",
                            "ansible_connection": "ssh",
                            "ansible_ssh_common_args" : "-o StrictHostKeyChecking=no",
                        }
                    elif i['groupname'].lower() == 'local':
                        i['hosts']['variable'] = self.arg['localaccount']
                for g in data['inventory']['groups']:
                    if g['groupname'] == i['groupname']:
                        g['hosts'].append(i['hosts'])
                        break
            data['play']['hosts'] = existgroup[0]

            module_file = 'copy'
            module_path = 'file'
            module_find = 'find'
            module_shell = 'shell'
            if data['play']['hosts'].lower() == 'windows':
                module_file = 'win_copy'
                module_path = 'win_file'
                module_find = 'win_find'
                module_shell = 'win_shell'



            #获取目标机器保存文件路径
            localtemp = ""
            for path in self.arg['filepath']:
                if path[0].lower() == data['play']['hosts'].lower():
                    localtemp = path[1]
                    break
            if not localtemp:
                self.logger.Log(3, "没有配置目标机器保存文件的目录，无法保存文件！")
                raise Exception("没有配置目标机器保存文件的目录，无法保存文件！")
            localtemp = os.path.join(localtemp,missionid)  + "/"

            #获取proxy保存文件路径
            if not self.arg.has_key('filepath'):
                self.logger.Log(3, "没有配置保存文件的目录，无法保存文件！")
                raise Exception("没有配置保存文件的目录，无法保存文件！")
            proxypath = None
            for path in self.arg['filepath']:
                if path[0] == 'proxy':
                    proxypath = path[1]
                    break
            if not proxypath:
                self.logger.Log(3, "没有配置保存文件的目录，无法保存文件！")
                raise Exception("没有配置保存文件的目录，无法保存文件！")
            if not os.path.exists(os.path.join(proxypath,missionid)):
                os.makedirs(os.path.join(proxypath,missionid))

            missionpath = os.path.join(proxypath,missionid) + "/"

            #先拷贝文件
            fileinfo = []
            for f in data['file']:
                if f['filename'] not in [sf['filename'] for sf in fileinfo]:
                    fileinfo.append(f)

            for f in fileinfo:
                #等待每个文件传输完成
                filename = f['templatename'] if f.has_key('templatename') else f['filename']
                i = 1
                while i < self.arg['TransferFileTimeout']:
                    #校验文件是否存在
                    if os.path.exists(os.path.join(missionpath,filename)):
                        break
                    i = i + 1
                    if i > self.arg['TransferFileTimeout']:
                        return False
                    time.sleep(1)

            #重组play
            fetchtasklist = []
            for task in data['play']['tasks']:
                if task['action']['module'] == 'find':
                    task['action']['module'] = module_find
                    task['action']['paths'] = localtemp
                    task['action']['recurse'] = 'no'
                    task['register'] = 'file_2_fetch'
                    fetchtask = {
                                    'action':{
                                        'src':'{{ item.path }}',
                                        'dest': missionpath,
                                        'flat':'yes',
                                        'module':'fetch',
                                        },
                                    'name':'Sync Folder',
                                    'with_items': "{{ file_2_fetch.files }}",
                                    'when': 'file_2_fetch is defined',
                                }
                    fetchtasklist.append(fetchtask)
                if task['action']['module'] == 'template':
                    task['action']['src'] = os.path.join(missionpath,task['action']['src'])
                    task['action']['dest'] = os.path.join(localtemp,task['action']['dest'])
                if task['action']['module'] == 'shell':
                    task['action']['module'] = module_shell
                    task['action']['chdir'] = localtemp
                    try:
                        suffix = task['action']['args'].split(" ")[0].split(".")[1]
                        if suffix:
                            if script_evr[suffix]:
                                task['action']['args'] = script_evr[suffix] + task['action']['args']
                    except Exception as e:
                        pass


            data['play']['tasks'].extend(fetchtasklist)

            #删除任务目录
            removemissionfolder = {
                            'action':{
                                'path': localtemp,
                                'state': 'absent',
                                'module': module_path,
                                },
                            'name':'Del Mission Folder',
                        }
            data['play']['tasks'].append(removemissionfolder)

            data['play']['tasks'].insert(0,{'action': {
                'module':module_file,
                'directory_mode': 'yes',
                'src': missionpath,
                'dest': localtemp,
            },
                'name': 'Sync Mission Files',
            })
            #创建任务目录
            data['play']['tasks'].insert(0,{'action': {
                'module': module_path,
                'path': localtemp,
                'state': 'directory',
            },
                'name': 'Create Mission Folder',
            })

            # self.logger.Log(1, data)
            #ansible开始处理
            callback = ansible.MyCallBack()
            job_inventory = ansible.MyInventory(data['inventory'])
            job_play = ansible.MyPlay(data['play'], job_inventory)
            job = ansible.TaskQueue(job_inventory, callback).TaskQueueManager
            do_job = job.run(job_play.play)
            job_result = job._stdout_callback.result
            result = True
            data['iptohostname'] = {v: k for k, v in data['hostnametoip'].items()}

            for r in job_result.keys():
                for c in job_result[r]:
                    if not c['code'].lower() == 'ok':
                        result = False
                        break
                        break
            for r in job_result.keys():
                if data['iptohostname'].has_key(r):
                    job_result[data['iptohostname'][r]] = job_result.pop(r)

            data['result'] = result
            data['detail'] = job_result
            data['tempfolder'] = missionpath

            self.logger.Log(1, data)
            # print data
            return data
        except Exception as e:
            a = traceback.format_exc()
            self.logger.Log(1, a)
            print a
            data['result'] = False
            data['detail'] = {"Total": [{"code": "FAILED", "command": "None", "result": {"task": data['mission']['missionname'], "stdout": "Mission Failed, please check more detail with admin!"}}]}
            return data

    def ListMision(self,missionlist,data):
        missionlist.insert(0,data)
        if data['partner']:
            for x in data['partner']:
                missionlist = self.ListMision(missionlist,x)
        return missionlist


    def ProxyWorkModule(self,data):
        result = None
        pushresult = None
        missionid = str(data['mission']['id'])
        missionlist = self.ListMision([],data)
        results = []
        for m in missionlist:
            if m['module'] == 'ansible':
                result = self.ProxyWorkModuleAnsible(m,missionid)
                if result:
                    results.append(result)
                    try:
                        if not result['result']:
                            break
                    except Exception as e:
                        a = traceback.format_exc()
                        self.logger.Log(1, a)
        if results:
            pushresult = {'mission': {'id': missionid }, 'detail': {}, 'tempfolder': [],}
            for r in results:
                pushresult['result'] = r['result']
                pushresult['tempfolder'].append(r['tempfolder'])
                try:
                    if r.has_key('detail'):
                        for key in r['detail'].keys():
                            if pushresult['detail'].has_key(key):
                                pushresult['detail'][key].extend(r['detail'][key])
                            else:
                                pushresult['detail'][key] = r['detail'][key]
                except Exception as e:
                    a = traceback.format_exc()
                    self.logger.Log(1, a)
        if pushresult:
            self.resultqueue.put(pushresult)
            for f in pushresult['tempfolder']:
                try:
                    for root, dirs, files in os.walk(f, topdown=False):
                        for name in files:
                            os.remove(os.path.join(root, name))
                        for name in dirs:
                            os.rmdir(os.path.join(root, name))
                    os.removedirs(f)
                except Exception as e:
                    a = traceback.format_exc()
                    self.logger.Log(1, a)
        threading.currentThread()._Thread__stop()


    # def BindPort(self):
    #     # print "BindPort"
    #     for bindinfo in self.bind:
    #         #建立监听线程
    #         threadname = 'StartBindTo' + bindinfo + "_" + self.GetTime()
    #         thread = MyThread(self.StartBind,bindinfo)
    #         thread.setName(threadname)
    #         thread.start()  #线程开始处理任务

    def StartBind(self,bindinfo):
        # print "StartBind"
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        print "Socket created"
        self.logger.Log(1, "Socket created")

        #Bind socket to local host and port
        try:
            s.bind((bindinfo.split(":")[0], int(bindinfo.split(":")[1])))
        except socket.error , msg:
            print "Bind failed. Error Code : " + str(msg[0]) + " Message " + msg[1] + "-------for------" + bindinfo
            self.logger.Log(3, "Bind failed. Error Code : " + str(msg[0]) + " Message " + msg[1] + "-------for------" + bindinfo)
            sys.exit()

        print bindinfo + " bind complete"
        self.logger.Log(1, bindinfo + " bind complete")
        #Start listening on socket
        s.listen(10)
        print bindinfo + " now listening"
        self.logger.Log(1, bindinfo + " now listening")
        while True:
            #wait to accept a connection - blocking call
            newconn, addr = s.accept()
            print "Connected with " + addr[0] + ":" + str(addr[1])
            self.logger.Log(1, bindinfo + " now listening")
            #建立通讯线程
            threadname = 'SocketWorker_' + self.GetTime()
            thread = MyThread(self.SocketWorker,newconn)
            thread.setName(threadname)
            thread.start()  #线程开始处理任务

        s.close()
        threading.currentThread()._Thread__stop()

    def SocketWorker(self,connection):
        # print "SocketWorker"

        data = connection.recv(40)
        data = data.split(" ")[1]
        try:
            if data == 'file':
                try:
                    if not self.arg.has_key('filepath'):
                        self.logger.Log(3, "没有配置保存文件的目录，无法保存文件！")
                        raise Exception("没有配置保存文件的目录，无法保存文件！")
                    proxypath = None
                    for path in self.arg['filepath']:
                        if path[0] == 'proxy':
                            proxypath = path[1]
                            break
                    if not proxypath:
                        self.logger.Log(3, "没有配置保存文件的目录，无法保存文件！")
                        raise Exception("没有配置保存文件的目录，无法保存文件！")
                    FILEINFO_SIZE = struct.calcsize(self.structpack)
                    fhead = connection.recv(FILEINFO_SIZE)
                    missionid, filename, filecode, size, partsize = struct.unpack(self.structpack, fhead)
                    missionid = missionid.strip('\00')
                    missionpath = os.path.join(proxypath,missionid)
                    if not os.path.exists(missionpath):
                        os.makedirs(missionpath)
                    missionpath = os.path.join(proxypath,missionid)
                    filename = os.path.join(missionpath,filename.strip('\00'))
                    filecode = filecode.strip('\00')
                    if os.path.exists(filename):
                        if self.GetFileMD5(filename) == filecode:
                            raise FileExists()
                        os.remove(filename)
                    temp_time = time.strftime('%Y%m%d%H%M%S', time.localtime(time.time())) + str(uuid.uuid1())
                    temp_filename = os.path.join(missionpath,'temp'+ temp_time)
                    current_size = 0
                    buffer = b""
                    f = open(temp_filename,'wb+')
                    while current_size < size:
                        try:
                            data = connection.recv(partsize)
                            if not data:
                                break
                            if len(data) + current_size > size:
                                data = data[:size-current_size] # trim additional data
                            buffer += data
                            f.write(data)
                            f.flush()
                            current_size += len(data)
                        except Exception as e:
                            a = traceback.format_exc()
                            self.logger.Log(1, a)
                            # traceback.format_exc()
                    f.close
                    if self.GetFileMD5(temp_filename) == filecode:
                        os.rename(temp_filename, filename)
                except FileExists:
                    self.logger.Log(1, "文件：" + filename + " 已存在，不重传！")
                    print "文件：" + filename + " 已存在，不重传！"
                    pass
                except Exception as e:
                    a = traceback.format_exc()
                    self.logger.Log(1, a)
                    pass
                finally:
                    connection.close()
            elif data == 'mission':
                data = self.RecvData(connection)
                self.workqueue.put(json.loads(data))
                connection.close()
            elif data == 'missionresult':
                data = self.RecvData(connection)
                self.resultqueue.put(json.loads(data))
                connection.close()
                pass
            else:
                connection.close()
        except Exception as e:
            # traceback.format_exc()
            a = traceback.format_exc()
            self.logger.Log(1, a)
        finally:
            threading.currentThread()._Thread__stop()

    def SendMission(self,arg):
        data = arg[0]
        proxy = arg[1]
        # print "SendMission"
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.connect((proxy.split(":")[0],int(proxy.split(":")[1])))
            s.send(self.FunctionDefined('mission'))
            self.SendData(s, json.dumps(data))
            s.close()
            threading.currentThread()._Thread__stop()
            return
        except Exception as e:
            a = traceback.format_exc()
            self.logger.Log(1, a)
            # traceback.format_exc()
            SocketReconnectInterval = 10
            if self.arg.has_key('SocketReconnectInterval'):
                SocketReconnectInterval = self.arg['SocketReconnectInterval']
            print "连接不上代理" + proxy + "将在" + str(SocketReconnectInterval) + "秒后重新尝试连接"
            self.logger.Log(3, "连接不上代理" + proxy + "将在" + str(SocketReconnectInterval) + "秒后重新尝试连接")
            time.sleep(SocketReconnectInterval)
            self.SendMission(arg)

    def SendFile(self,arg):
        data = arg[0]
        proxy = arg[1]
        # print "SendFile"
        try:
            for file in data['file']:
                s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                s.connect((proxy.split(":")[0],int(proxy.split(":")[1])))
                s.send(self.FunctionDefined('file'))
                try:
                    if os.path.exists(file['filepath']):
                        filesize = os.stat(file['filepath']).st_size
                        if filesize / (1024*1024*1024) > 0:
                            partsize = 40960
                        elif filesize / (1024*1024*10) > 0:
                            partsize = 4096
                        else:
                            partsize = 1024
                        filename = str(file['templatename']) if file.has_key('templatename') else str(file['filename'])
                        fhead = struct.pack(self.structpack, str(data['mission']['id']), filename, str(file['fileidcode']), filesize, partsize)  # 按照规则进行打包
                        s.send(fhead)  # 发送文件基本信息数据
                        current_size = 0
                        with open(file['filepath'], 'r') as infile:
                            d = infile.read(partsize)
                            while d:
                                try:
                                    current_size = len(d) + current_size
                                    s.send(d)
                                    d = infile.read(partsize)
                                except IOError:
                                    break
                                except Exception as e:
                                    a = traceback.format_exc()
                                    self.logger.Log(1, a)
                                    print a
                                    break
                    else:
                        print file['filename'] + ' not found'
                except Exception as e:
                    a = traceback.format_exc()
                    self.logger.Log(1, a)
                    print a
                    pass
                finally:
                    s.close()
            thread.exit()
            return
        except Exception as e:
            a = traceback.format_exc()
            self.logger.Log(1, a)
            # traceback.format_exc()
            SocketReconnectInterval = 10
            if self.arg.has_key('SocketReconnectInterval'):
                SocketReconnectInterval = self.arg['SocketReconnectInterval']
            print "连接不上代理" + proxy + "将在" + str(SocketReconnectInterval) + "秒后重新尝试连接"
            self.logger.Log(3, "连接不上代理" + proxy + "将在" + str(SocketReconnectInterval) + "秒后重新尝试连接")
            time.sleep(SocketReconnectInterval)
            self.SendMission(arg)

    def ServerWorker(self):
        # print "ServerWorker"
        while True:
            data = self.workqueue.get()
            if data:
                if self.proxyurl:
                    proxycount = len(proxyurl)
                    targetlist = self.DivList(data['target'],proxycount)
                    for proxy in self.proxyurl:
                        data['target'] = targetlist.pop()
                        #建立发送任务线程
                        threadname = 'SendMission_' + proxy[0] + "_" + self.GetTime()
                        thread = MyThread(self.SendMission,(data,proxy[0]))
                        thread.setName(threadname)
                        thread.start()  #线程开始处理任务

                        if data['file']:
                            #建立发送文件线程
                            threadname = 'SendFile_' + proxy[0] + "_" + self.GetTime()
                            thread = MyThread(self.SendFile,(data,proxy[0]))
                            thread.setName(threadname)
                            thread.start()  #线程开始处理任务

    def ProxyWorker(self):
        # print "ProxyWorker"
        print "start ProxyWorker"
        while True:
            data = self.workqueue.get()
            if data:
                threadname = 'ProxyWorkModule_' + str(data['mission']['id']) + "_" + self.GetTime()
                thread = MyThread(self.ProxyWorkModule,(data))
                thread.setName(threadname)
                thread.start()  #线程开始处理任务

        print "end ProxyWorker"

    def Run(self):
        print "run"
        #建立守护线程
        threadname = 'Guard_' + self.GetTime()
        thread = MyThread(self.Guard)
        thread.setName(threadname)
        thread.start()  #线程开始处理任务



if __name__ == "__main__":


    #监控退出指令
    # Watcher()

    #配置文件
    configfile = ""

    #服务类型
    servertype = ""

    try:
        opts, args = getopt.getopt(sys.argv[1:], "c:t:d", ["config", "type","debug"])
    except getopt.GetoptError:
        pass
        # print help information and exit:

    for o, a in opts:
        if o in ("-c", "--config"):
            configfile = a
        if o in ("-t", "--type"):
            servertype = a
        if o in ("-d", "--debug"):
            # 监控退出指令
            Watcher()

    if not servertype.lower() in ['server','proxy']:
        print "服务类型为server或proxy"
        sys.exit()

    if configfile:
        if not os.path.exists(configfile):
            print "配置文件不存在"
            sys.exit()

    if os.path.dirname(configfile):
        os.sys.path.append(os.path.dirname(configfile))

    configfilename = None
    if os.path.basename(configfile):
        filelist = os.path.basename(configfile).split(".")
        filelist.pop()
        configfilename = ".".join(filelist)
        try:
            config = __import__(configfilename)
        except Exception as e:
            print "获取配置文件内容失败"
            self.logger.Log(3, "获取配置文件内容失败")
            sys.exit()

    if not configfilename:
        print "获取配置文件内容失败"
        sys.exit()

    config = __import__(configfilename)
    arg = {}
    bind = config.listener if config.listener else None

    #附加的参数
    try:
        arg['GetMissionInterval'] = config.GetMissionInterval
    except Exception as e:
        arg['GetMissionInterval'] = None

    try:
        arg['SocketListenTimeout'] = config.SocketListenTimeout
    except Exception as e:
        arg['SocketListenTimeout'] = None

    try:
        arg['SocketReconnectInterval'] = config.SocketReconnectInterval
    except Exception as e:
        arg['SocketReconnectInterval'] = None

    try:
        arg['filepath'] = config.filepath
    except Exception as e:
        arg['filepath'] = None

    try:
        arg['localaccount'] = config.localaccount
    except Exception as e:
        arg['localaccount'] = None

    try:
        arg['TransferFileTimeout'] = config.TransferFileTimeout
    except Exception as e:
        arg['TransferFileTimeout'] = None

    try:
        weburl = config.weburl
    except Exception as e:
        weburl = None

    try:
        token = config.token
    except Exception as e:
        token = None

    try:
        proxyurl = config.proxyurl
    except Exception as e:
        proxyurl = None

    try:
        serverurl = config.serverurl
    except Exception as e:
        serverurl = None

    try:
        loglevel = config.loglevel
    except Exception as e:
        loglevel = None

    try:
        logpath = config.logpath
    except Exception as e:
        logpath = None

    configinfo = {
        'bind': bind,
        'weburl': weburl,
        'token': token,
        'serverurl': serverurl,
        'worktype': servertype,
        'proxyurl': proxyurl,
        'arg': arg,
        'loglevel': loglevel,
        'logpath': logpath,
    }

    server = DevopsWorker(**configinfo)

    server.Run()
#
